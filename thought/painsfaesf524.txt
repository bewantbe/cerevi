
2025-06-11 Continue the round two
=================================


# User request

Write a modern web app, with frontend and backend, and docker-compose.

Clear project structure. Modularized code that is easy to re-use and extend.

Should have a good performance and smooth user experience.

## Frontend

Use Vue.js single file components and pinia, in TypeScript.

Support multi-language (English and Chinese)

Parimary pages and components:

### page: Home page

Intro to: Volumetric Imaging with Synchronized on-the-fly-scan and Readout (VISoR) for high-throughput, high-quality brain mapping, from mouse brain to monkey brain and human brain at micro-meter resolution.

List of demo specimen (clickable, with basic info and image thumb):
* mouse brain
* mouse whole body
* macaque brain
* human brain

Copyright

### page: brain image and atlas

Once clicked a specimen. User goes to this page, showing the interactive brain(or tissue) image.

The page contains 3-views of the tissue images (sagittalis, horizontal, coronal), and an additional 3D view of brain shell (mesh, may use Three.js).

The 3-views images are multi-resolution, can be zoomed in or out (Using OpenSeadragon) with mouse. Possibly multi-channeled and with brain region mask.

The same page contains a left pannel for control and information. There several tabs: 

  * Basic info and meta data about the sample and image;
  * For tuning the brightness and contrast of the image;
  * Enable/disable showing the brain region mask (overlayed(mixed) with the brain image);
  * Brain region list, that can be clicked (checked) to highlight the brain area.

URLs are copy-paste-friendly, i.e. user with the same URL should see the same page and same image position.


## backend

Python FastAPI server that privides basic info and images to the frontend. Specifically:

* The images of each demo specimen are stored in a hdf5 file, 3D image array with resolution pyramid. The backend serves the images that are suitable for frontend.

* Serves brain (or tissue) region list (names, ids) for each specimen.

* Serves brain (or tissue) region mask, also in hd5 file. the pixel values of the mask are the region ids. Generally has different resolution to corresponding images.


# Implementation plan

## Complete VISoR Platform Implementation Plan

### Final Architecture Overview

```mermaid
graph TB
    subgraph "Frontend (Vue.js + TypeScript)"
        A[Home Page] --> B[Atlas Viewer]
        B --> C[ViewerGrid - 4 Panels]
        C --> D[Sagittal View - YZ plane]
        C --> E[Coronal View - XZ plane] 
        C --> F[Horizontal View - XY plane]
        C --> G[3D Brain Shell]
        H[Control Panel] --> I[Metadata Tab]
        H --> J[Channel Controls]
        H --> K[Atlas Overlay]
        H --> L[Region Browser]
        M[Region Picker] --> N[Coordinate Transform]
        O[Pinia Store] --> B
        P[Vue Router] --> Q[URL State Management]
    end
    
    subgraph "Backend (FastAPI + Python)"
        R[FastAPI Server] --> S[Imaris Handler]
        R --> T[Tile Service]
        R --> U[Region Service]
        R --> V[Metadata Service]
        S --> W[HDF5 Image Data]
        T --> X[Image Tiles JPEG]
        T --> Y[Atlas Tiles PNG]
        U --> Z[Region Hierarchy JSON]
        AA[3D Model Service] --> BB[OBJ File Handler]
        CC[Coordinate Transform] --> DD[View Mapping]
    end
    
    subgraph "Data Layer"
        EE[Image: z00000_c1_1.ims]
        FF[Atlas: z00000_c1_mask.ims]
        GG[Model: 1.obj]
        HH[Regions: NIHMS696288-supplement-4.xlsx → JSON]
    end
    
    subgraph "Infrastructure"
        II[Docker Compose]
        JJ[Redis Cache]
        KK[Nginx Proxy]
    end
```

### Complete Project Structure

```
cerevi/
├── docker-compose.yml
├── .env.example
├── README.md
├── data/                                    # Symbolic links
│   ├── specimens/
│   │   └── macaque_brain_rm009/
│   │       ├── image.ims -> /share/data/VISoR_Reconstruction/...
│   │       └── atlas.ims -> /share/data/VISoR_Reconstruction/.../mask.ims
│   ├── models/
│   │   └── macaque_brain_rm009/
│   │       └── brain_shell.obj -> /mnt/xyy/SIAT_CAS/xu/tracing/.../1.obj
│   └── regions/
│       └── macaque_brain_regions.xlsx -> /mnt/xyy/SIAT_CAS/xu/.../NIHMS696288-supplement-4.xlsx
├── frontend/
│   ├── Dockerfile
│   ├── package.json
│   ├── vite.config.ts
│   ├── tsconfig.json
│   ├── tailwind.config.js
│   ├── src/
│   │   ├── main.ts
│   │   ├── App.vue
│   │   ├── router/
│   │   │   └── index.ts
│   │   ├── stores/
│   │   │   ├── specimen.ts               # Specimen data management
│   │   │   ├── viewer.ts                 # Viewer state (position, zoom, etc.)
│   │   │   ├── region.ts                 # Region hierarchy and selection
│   │   │   └── ui.ts                     # UI state (maximized view, etc.)
│   │   ├── views/
│   │   │   ├── HomePage.vue
│   │   │   └── AtlasViewer.vue
│   │   ├── components/
│   │   │   ├── layout/
│   │   │   │   ├── Header.vue
│   │   │   │   └── Footer.vue
│   │   │   ├── home/
│   │   │   │   ├── HeroSection.vue
│   │   │   │   ├── SpecimenGallery.vue
│   │   │   │   └── SpecimenCard.vue
│   │   │   ├── viewer/
│   │   │   │   ├── ViewerGrid.vue        # 4-panel layout manager
│   │   │   │   ├── ViewerPanel.vue       # Individual 2D/3D viewer
│   │   │   │   ├── ViewMaximizer.vue     # Maximized single view
│   │   │   │   ├── OpenSeadragonViewer.vue # 2D image viewer
│   │   │   │   └── ThreeJSViewer.vue     # 3D brain shell viewer
│   │   │   ├── controls/
│   │   │   │   ├── ControlPanel.vue      # Left panel container
│   │   │   │   ├── MetadataTab.vue       # Image info, dimensions
│   │   │   │   ├── ChannelTab.vue        # Channel selection, contrast
│   │   │   │   ├── AtlasTab.vue          # Atlas overlay controls
│   │   │   │   └── RegionTab.vue         # Hierarchical region browser
│   │   │   ├── region/
│   │   │   │   ├── RegionTree.vue        # Hierarchical tree display
│   │   │   │   ├── RegionSearch.vue      # Search regions
│   │   │   │   └── RegionPicker.vue      # Click-to-pick functionality
│   │   │   └── ui/
│   │   │       ├── LanguageToggle.vue
│   │   │       ├── LoadingSpinner.vue
│   │   │       └── ErrorBoundary.vue
│   │   ├── composables/
│   │   │   ├── useOpenSeadragon.ts       # OpenSeadragon integration
│   │   │   ├── useThreeJS.ts             # Three.js 3D visualization
│   │   │   ├── useViewerLayout.ts        # Grid/maximize state management
│   │   │   ├── useRegionPicker.ts        # Region picking logic
│   │   │   ├── useCoordinateTransform.ts # View coordinate mapping
│   │   │   ├── useImageControls.ts       # Brightness, contrast controls
│   │   │   └── useUrlState.ts            # URL state synchronization
│   │   ├── services/
│   │   │   ├── api.ts                    # Main API client
│   │   │   ├── tileService.ts            # Tile loading service
│   │   │   └── coordinateService.ts      # Coordinate transformations
│   │   ├── types/
│   │   │   ├── specimen.ts
│   │   │   ├── viewer.ts
│   │   │   ├── region.ts
│   │   │   └── api.ts
│   │   ├── utils/
│   │   │   ├── constants.ts
│   │   │   ├── helpers.ts
│   │   │   └── validation.ts
│   │   ├── locales/
│   │   │   ├── en.json
│   │   │   └── zh.json
│   │   └── assets/
│   │       ├── images/
│   │       └── styles/
│   └── public/
├── backend/
│   ├── Dockerfile
│   ├── requirements.txt
│   ├── app/
│   │   ├── main.py
│   │   ├── config.py                     # Configuration management
│   │   ├── models/
│   │   │   ├── specimen.py               # Specimen data models
│   │   │   ├── region.py                 # Region hierarchy models
│   │   │   ├── metadata.py               # Image metadata models
│   │   │   └── coordinate.py             # Coordinate system models
│   │   ├── services/
│   │   │   ├── imaris_handler.py         # .ims file reading
│   │   │   ├── tile_service.py           # Tile generation
│   │   │   ├── region_service.py         # Region data management
│   │   │   ├── coordinate_service.py     # Coordinate transformations
│   │   │   ├── obj_handler.py            # 3D model handling
│   │   │   ├── metadata_service.py       # Image metadata extraction
│   │   │   └── cache_service.py          # Redis caching
│   │   ├── api/
│   │   │   ├── specimens.py              # Specimen endpoints
│   │   │   ├── tiles.py                  # Tile serving endpoints
│   │   │   ├── regions.py                # Region endpoints
│   │   │   ├── metadata.py               # Metadata endpoints
│   │   │   └── models.py                 # 3D model endpoints
│   │   ├── utils/
│   │   │   ├── excel_parser.py           # Convert XLSX to JSON
│   │   │   ├── image_processing.py       # Image manipulation
│   │   │   ├── coordinate_math.py        # Coordinate calculations
│   │   │   └── validation.py             # Input validation
│   │   └── data/
│   │       └── processed/
│   │           └── regions.json          # Converted region hierarchy
│   └── tests/
├── nginx/
│   ├── Dockerfile
│   └── nginx.conf
└── scripts/
    ├── setup_data_links.sh               # Create symbolic links
    ├── convert_regions.py                # Convert XLSX to JSON
    └── init_dev_data.py                  # Initialize development data
```

### Coordinate System Implementation

#### Backend Coordinate Service:
```python
class CoordinateService:
    def __init__(self):
        # Image array is in (z, y, x) order
        # Right-handed coordinate system
        self.view_mappings = {
            'sagittal': {   # YZ plane (perpendicular to X-axis)
                'array_axes': (0, 1),  # z, y from (z,y,x)
                'display_axes': ('anterior-posterior', 'superior-inferior')
            },
            'coronal': {    # XZ plane (perpendicular to Y-axis)  
                'array_axes': (0, 2),  # z, x from (z,y,x)
                'display_axes': ('anterior-posterior', 'left-right')
            },
            'horizontal': { # XY plane (perpendicular to Z-axis)
                'array_axes': (1, 2),  # y, x from (z,y,x)
                'display_axes': ('superior-inferior', 'left-right')
            }
        }
    
    def get_slice_from_3d(self, data: np.ndarray, view: str, slice_idx: int) -> np.ndarray:
        if view == 'sagittal':
            return data[:, :, slice_idx]  # Fix X, vary Z,Y
        elif view == 'coronal':
            return data[:, slice_idx, :]  # Fix Y, vary Z,X
        elif view == 'horizontal':
            return data[slice_idx, :, :]  # Fix Z, vary Y,X
    
    def transform_3d_to_model(self, image_coords: tuple, resolution_um: float) -> tuple:
        # Transform from image coordinates to 3D model coordinates
        # Image resolution at level 0 is 10um
        # Model coordinates are in 10um units
        x, y, z = image_coords
        model_x = x * resolution_um / 10.0
        model_y = y * resolution_um / 10.0  
        model_z = z * resolution_um / 10.0
        return (model_x, model_z, -model_y)  # Note: Y becomes -Y in model
```

### Complete API Specification

#### Core Endpoints:
```python
# Specimen Management
GET /api/specimens                                    # List all specimens
GET /api/specimens/{id}                              # Get specimen details
GET /api/specimens/{id}/metadata                     # Complete metadata

# Tile Serving (configurable tile size, default 512x512)
GET /api/specimens/{id}/image/{view}/{level}/{z}/{x}/{y}?channel={ch}&tile_size={size}
GET /api/specimens/{id}/atlas/{view}/{level}/{z}/{x}/{y}?tile_size={size}

# Region System
GET /api/specimens/{id}/regions                      # Complete region hierarchy
GET /api/specimens/{id}/regions/{region_id}          # Specific region details
POST /api/specimens/{id}/pick-region                 # Pick region from coordinates
# Body: {"view": "sagittal", "x": 100, "y": 200, "z": 50, "level": 4}

# 3D Models
GET /api/specimens/{id}/model                        # Get 3D brain shell model
GET /api/specimens/{id}/model/metadata               # Model alignment info

# Metadata & Configuration
GET /api/specimens/{id}/image-info                   # Dimensions, levels, channels
GET /api/specimens/{id}/atlas-info                   # Atlas dimensions, levels
GET /api/specimens/{id}/config                       # Suggested tile size, etc.
```

### Region Hierarchy Data Structure

#### Converted JSON Format:
```json
{
  "regions": [
    {
      "id": 1,
      "name": "ventricles",
      "abbreviation": "LV",
      "level1": "ventricles",
      "level2": "ventricles", 
      "level3": "ventricles",
      "level4": "ventricles",
      "value": 1,
      "parent_id": null,
      "children": []
    },
    {
      "id": 2,
      "name": "medulla",
      "abbreviation": "Md",
      "level1": "hindbrain",
      "level2": "myelencephalon",
      "level3": "medulla",
      "level4": "medulla",
      "value": 2,
      "parent_id": null,
      "children": []
    }
  ],
  "hierarchy": {
    "hindbrain": {
      "myelencephalon": ["medulla"],
      "metencephalon": ["pons", "cerebellum"]
    },
    "midbrain": ["midbrain"],
    "forebrain": {
      "diencephalon": {
        "p2": ["thalamus"]
      }
    }
  }
}
```

### Frontend State Management (Pinia Stores)

#### Viewer Store:
```typescript
export const useViewerStore = defineStore('viewer', () => {
  const currentView = ref<'grid' | 'sagittal' | 'coronal' | 'horizontal' | '3d'>('grid')
  const viewerStates = ref({
    sagittal: { position: [0, 0, 0], zoom: 1, slice: 0 },
    coronal: { position: [0, 0, 0], zoom: 1, slice: 0 },
    horizontal: { position: [0, 0, 0], zoom: 1, slice: 0 }
  })
  const synchronizeViews = ref(true)
  const selectedRegion = ref<number | null>(null)
  const channelSettings = ref({
    activeChannels: [0],
    brightness: { 0: 50, 1: 50, 2: 50, 3: 50 },
    contrast: { 0: 50, 1: 50, 2: 50, 3: 50 }
  })
  
  const maximizeView = (view: string) => {
    currentView.value = view as any
  }
  
  const syncPosition = (sourceView: string, position: number[]) => {
    if (!synchronizeViews.value) return
    // Update corresponding positions in other views
  }
  
  return {
    currentView, viewerStates, synchronizeViews, selectedRegion,
    channelSettings, maximizeView, syncPosition
  }
})
```

### Performance & Caching Strategy

#### Backend Caching:
```python
class CacheService:
    def __init__(self):
        self.redis = redis.Redis(host='redis', port=6379, db=0)
        self.tile_cache_ttl = 3600  # 1 hour
        self.metadata_cache_ttl = 86400  # 24 hours
    
    def get_tile_cache_key(self, specimen_id: str, tile_type: str, 
                          view: str, level: int, z: int, x: int, y: int, **kwargs) -> str:
        extras = "_".join([f"{k}={v}" for k, v in sorted(kwargs.items())])
        return f"tile:{specimen_id}:{tile_type}:{view}:{level}:{z}:{x}:{y}:{extras}"
    
    async def get_cached_tile(self, cache_key: str) -> Optional[bytes]:
        return await self.redis.get(cache_key)
    
    async def cache_tile(self, cache_key: str, tile_data: bytes):
        await self.redis.setex(cache_key, self.tile_cache_ttl, tile_data)
```

#### Frontend Optimizations:
- **Progressive loading**: Load low-resolution first, then high-resolution
- **Viewport culling**: Only load visible tiles
- **Memory management**: Dispose of off-screen tiles
- **Debounced updates**: Prevent excessive API calls during navigation

### Docker Composition

#### docker-compose.yml:
```yaml
version: '3.8'
services:
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    environment:
      - VITE_API_URL=http://localhost:8000
    depends_on:
      - backend
  
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - REDIS_URL=redis://redis:6379
    volumes:
      - ./data:/app/data:ro
    depends_on:
      - redis
  
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    command: redis-server --maxmemory 2gb --maxmemory-policy allkeys-lru
  
  nginx:
    build: ./nginx
    ports:
      - "80:80"
    depends_on:
      - frontend
      - backend
```

### Implementation Phases

#### Phase 1: Data Setup & Infrastructure
1. Create all symbolic links to data files
2. Convert XLSX region hierarchy to JSON
3. Set up basic Docker composition
4. Test data access and file reading

#### Phase 2: Backend Core
1. Implement ImarisHandler for .ims files
2. Create TileService with multi-resolution support
3. Build coordinate transformation system
4. Add caching layer with Redis

#### Phase 3: API Implementation
1. Create all REST endpoints
2. Implement region picking logic
3. Add 3D model serving
4. Test with real data

#### Phase 4: Frontend Foundation
1. Set up Vue.js project with TypeScript
2. Create routing and basic layout
3. Implement Pinia stores
4. Build ViewerGrid component

#### Phase 5: 2D Visualization
1. Integrate OpenSeadragon
2. Implement multi-view synchronization
3. Add region picking functionality
4. Create control panels

#### Phase 6: 3D Visualization
1. Three.js integration for brain shell
2. Coordinate alignment with 2D views
3. Interactive controls

#### Phase 7: Advanced Features
1. Multi-channel support
2. Region hierarchy browser
3. Atlas overlay system
4. URL state management

#### Phase 8: Polish & Optimization
1. Internationalization (EN/CN)
2. Performance optimization
3. Error handling and loading states
4. Documentation and testing

## Ready for Implementation

This comprehensive plan covers all aspects of the VISoR platform with real data integration. The architecture is designed for:

- **Scalability**: Modular structure, caching, efficient data handling
- **Performance**: Progressive loading, viewport culling, optimized tile serving
- **Usability**: Intuitive 4-panel layout, synchronized navigation, region picking
- **Maintainability**: Clear separation of concerns, TypeScript types, comprehensive testing


# Next

Carefully check what have been done, and what have been done wrong.

Then continue follow plan.



==================

## 📊 Current Status Analysis: VISoR Platform Implementation

Based on my review of the project files, here's what has been completed and what needs attention:

### ✅ **What's Been Done Well**

#### **Backend Infrastructure (COMPLETE)**
- ✅ **Production-ready FastAPI backend** with 275GB data handling
- ✅ **Docker containerization** with Redis caching
- ✅ **Complete API endpoints** for specimens, tiles, regions, metadata
- ✅ **Multi-resolution image processing** (8 levels, 4 channels)
- ✅ **Brain region analysis** (241 regions with hierarchy)
- ✅ **Coordinate system handling** for 3D transformations
- ✅ **Performance optimization** with caching and health monitoring

#### **Frontend Foundation (MOSTLY COMPLETE)**
- ✅ **Vue.js 3 + TypeScript setup** with modern architecture
- ✅ **Essential dependencies** installed (Element Plus, OpenSeadragon, Three.js, Axios)
- ✅ **Project structure** with proper component organization
- ✅ **Basic components** for home page, atlas viewer, layout
- ✅ **State management** with Pinia store
- ✅ **API client** setup for backend communication

#### **Infrastructure (COMPLETE)**
- ✅ **Docker Compose** multi-service orchestration
- ✅ **Nginx proxy** configuration
- ✅ **Data mounting** with symbolic links to real datasets
- ✅ **Environment configuration** and scripts

### 🚨 **Critical Missing Components**

The documentation claims completion, but examining the actual frontend source reveals **several core visualization components are missing**:

#### **Missing Image Visualization**
1. **OpenSeadragon Integration**: No actual image viewer component implemented
2. **Three.js 3D Viewer**: Missing brain shell rendering component
3. **ViewerGrid**: Multi-panel layout not implemented
4. **Coordinate Synchronization**: View sync logic missing

#### **Missing Control Systems**
1. **ControlPanel**: Only placeholder structure exists
2. **Channel Controls**: No brightness/contrast adjustment
3. **Region Browser**: Hierarchical tree component missing
4. **Atlas Overlay**: Region mask rendering not implemented

#### **Missing Core Composables**
1. **useOpenSeadragon**: Image viewer integration logic
2. **useThreeJS**: 3D visualization composable
3. **useCoordinateTransform**: View coordinate mapping
4. **useRegionPicker**: Click-to-identify regions

### 🎯 **Next Phase: Complete the Image Visualization**

#### **Priority 1: Core Image Viewer (Phase 5 from original plan)**
```
Missing Components:
├── OpenSeadragonViewer.vue    # 2D image tile viewer
├── ThreeJSViewer.vue          # 3D brain shell renderer
├── ViewerGrid.vue             # 4-panel synchronized layout
└── ViewerPanel.vue            # Individual view container
```

#### **Priority 2: Control Panel Implementation**
```
Missing Components:
├── MetadataTab.vue            # Image info display
├── ChannelTab.vue             # Multi-channel controls
├── AtlasTab.vue               # Region overlay controls
└── RegionTab.vue              # Hierarchical region browser
```

#### **Priority 3: Advanced Interactions**
```
Missing Features:
├── Region picking (click-to-identify)
├── View synchronization (position/zoom)
├── Channel blending controls
└── URL state management
```

### 🛠 **Recommended Implementation Plan**

#### **Phase 1: OpenSeadragon Integration**
- Implement `OpenSeadragonViewer.vue` component
- Create `useOpenSeadragon` composable for tile loading
- Connect to backend tile API endpoints
- Add zoom/pan controls with coordinate tracking

#### **Phase 2: Multi-View Layout**
- Build `ViewerGrid.vue` for sagittal/coronal/horizontal views
- Implement view synchronization logic
- Add maximize/minimize functionality
- Create coordinate transformation utilities

#### **Phase 3: 3D Visualization**
- Implement `ThreeJSViewer.vue` with brain shell mesh
- Load OBJ model from backend
- Add camera controls (orbit, zoom, pan)
- Sync 3D position with 2D views

#### **Phase 4: Control Panels**
- Complete all control tab components
- Implement channel selection and blending
- Build hierarchical region browser
- Add region picking functionality

#### **Phase 5: Integration & Polish**
- URL state management for shareable links
- Performance optimization and caching
- Error handling and loading states
- Multi-language support

### 🎯 **Immediate Next Steps**

The project has excellent foundation but needs the core visualization components implemented. The backend is production-ready and the frontend structure is solid - we just need to build the actual image viewing functionality.

**Would you like me to:**
1. **Start implementing the OpenSeadragon image viewer** component?
2. **Build the Three.js 3D brain visualization** component?
3. **Create the multi-view grid layout** with synchronization?
4. **Focus on the control panels** and region browser first?

The backend API is ready to serve tiles and data, so we can immediately start building these visualization components and see real brain imaging data in action!


=====================


## 🚀 **Implementation Plan: Complete VISoR Image Visualization**

Perfect! I'll proceed with implementing the missing core visualization components. Here's my detailed implementation strategy:

### **Phase 1: OpenSeadragon Image Viewer** 🖼️

#### **Component: OpenSeadragonViewer.vue**
```vue
<template>
  <div class="openseadragon-container" ref="viewerContainer">
    <div class="viewer-overlay">
      <div class="coordinates-display">
        {{ currentCoordinates }}
      </div>
      <div class="zoom-controls">
        <el-button-group>
          <el-button @click="zoomIn">+</el-button>
          <el-button @click="zoomOut">-</el-button>
          <el-button @click="resetView">Reset</el-button>
        </el-button-group>
      </div>
    </div>
  </div>
</template>
```

#### **Composable: useOpenSeadragon.ts**
```typescript
export function useOpenSeadragon(containerRef: Ref<HTMLElement>) {
  const viewer = ref<OpenSeadragon.Viewer | null>(null)
  const coordinates = ref({ x: 0, y: 0, z: 0 })
  
  const initViewer = (specimenId: string, view: 'sagittal' | 'coronal' | 'horizontal') => {
    viewer.value = OpenSeadragon({
      element: containerRef.value,
      tileSources: {
        getTileUrl: (level, x, y) => 
          `/api/specimens/${specimenId}/image/${view}/${level}/${coordinates.value.z}/${x}/${y}`
      }
    })
  }
  
  return { viewer, coordinates, initViewer }
}
```

### **Phase 2: Three.js 3D Brain Viewer** 🧠

#### **Component: ThreeJSViewer.vue**
```vue
<template>
  <div class="threejs-container" ref="containerRef">
    <div class="controls-overlay">
      <el-slider v-model="opacity" :min="0" :max="100" />
      <el-button @click="resetCamera">Reset View</el-button>
    </div>
  </div>
</template>
```

#### **Composable: useThreeJS.ts**
```typescript
export function useThreeJS(containerRef: Ref<HTMLElement>) {
  const scene = new THREE.Scene()
  const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000)
  const renderer = new THREE.WebGLRenderer({ antialias: true })
  
  const loadBrainModel = async (specimenId: string) => {
    const loader = new OBJLoader()
    const model = await loader.loadAsync(`/api/specimens/${specimenId}/model`)
    scene.add(model)
  }
  
  return { scene, camera, renderer, loadBrainModel }
}
```

### **Phase 3: Multi-View Grid Layout** 📊

#### **Component: ViewerGrid.vue**
```vue
<template>
  <div class="viewer-grid" :class="gridLayout">
    <div class="view-panel sagittal" @click="maximizeView('sagittal')">
      <OpenSeadragonViewer :specimen-id="specimenId" view="sagittal" />
    </div>
    <div class="view-panel coronal" @click="maximizeView('coronal')">
      <OpenSeadragonViewer :specimen-id="specimenId" view="coronal" />
    </div>
    <div class="view-panel horizontal" @click="maximizeView('horizontal')">
      <OpenSeadragonViewer :specimen-id="specimenId" view="horizontal" />
    </div>
    <div class="view-panel threejs" @click="maximizeView('3d')">
      <ThreeJSViewer :specimen-id="specimenId" />
    </div>
  </div>
</template>
```

#### **Synchronization Logic**
```typescript
// In stores/viewer.ts
export const useViewerStore = defineStore('viewer', () => {
  const syncPosition = (sourceView: string, position: [number, number, number]) => {
    if (!synchronizeViews.value) return
    
    // Convert coordinates between views
    const sagittalPos = convertToSagittal(position)
    const coronalPos = convertToCoronal(position) 
    const horizontalPos = convertToHorizontal(position)
    
    // Update all viewers
    updateViewerPosition('sagittal', sagittalPos)
    updateViewerPosition('coronal', coronalPos)
    updateViewerPosition('horizontal', horizontalPos)
  }
})
```

### **Phase 4: Control Panels** 🎛️

#### **Component: ChannelTab.vue**
```vue
<template>
  <div class="channel-controls">
    <div v-for="(channel, index) in channels" :key="index" class="channel-row">
      <el-checkbox v-model="channel.enabled">{{ channel.name }}</el-checkbox>
      <el-slider v-model="channel.brightness" :min="0" :max="100" />
      <el-slider v-model="channel.contrast" :min="0" :max="100" />
    </div>
  </div>
</template>
```

#### **Component: RegionTab.vue**
```vue
<template>
  <div class="region-browser">
    <el-input v-model="searchTerm" placeholder="Search regions..." />
    <el-tree 
      :data="regionHierarchy" 
      :filter-node-method="filterRegions"
      @node-click="selectRegion"
    />
  </div>
</template>
```

### **Phase 5: Region Picking System** 🎯

#### **Composable: useRegionPicker.ts**
```typescript
export function useRegionPicker() {
  const pickRegion = async (
    specimenId: string, 
    view: string, 
    coordinates: [number, number, number]
  ) => {
    const response = await api.post(`/api/specimens/${specimenId}/pick-region`, {
      view,
      x: coordinates[0],
      y: coordinates[1], 
      z: coordinates[2]
    })
    return response.data.region
  }
  
  return { pickRegion }
}
```

### **Implementation Order** 📝

1. **Start with OpenSeadragon** - Core image viewing capability
2. **Add ViewerGrid layout** - Multi-panel structure  
3. **Implement Three.js viewer** - 3D brain visualization
4. **Build control panels** - User interaction controls
5. **Add region picking** - Interactive region identification
6. **Integrate synchronization** - Coordinate view linking

### **Technical Specifications**

#### **Tile Loading Strategy**
- Progressive loading (low-res first, then high-res)
- Viewport-based culling (only load visible tiles)
- Memory management (dispose off-screen tiles)
- Caching with service worker

#### **Coordinate Systems**
- Backend: Right-handed (Z-Y-X axis order)
- Frontend: Convert to display coordinates
- Synchronization: Real-time coordinate mapping between views

#### **Performance Targets**
- Tile loading: < 500ms
- View switching: < 200ms  
- 3D rendering: 60fps
- Memory usage: < 2GB for full dataset

### **Ready to Implement!** 🎯

The plan is comprehensive and builds upon the excellent foundation already in place. Each component will integrate seamlessly with the existing backend API and frontend architecture.

**To proceed with implementation, please toggle to Act mode** and I'll start building these visualization components step by step, beginning with the OpenSeadragon image viewer!





