
2025-06-11 Continue the round four
==================================


# User request

Write a modern web app, with frontend and backend, and docker-compose.

Clear project structure. Modularized code that is easy to re-use and extend.

Should have a good performance and smooth user experience.

## Frontend

Use Vue.js single file components and pinia, in TypeScript.

Support multi-language (English and Chinese)

Parimary pages and components:

### page: Home page

Intro to: Volumetric Imaging with Synchronized on-the-fly-scan and Readout (VISoR) for high-throughput, high-quality brain mapping, from mouse brain to monkey brain and human brain at micro-meter resolution.

List of demo specimen (clickable, with basic info and image thumb):
* mouse brain
* mouse whole body
* macaque brain
* human brain

Copyright

### page: brain image and atlas

Once clicked a specimen. User goes to this page, showing the interactive brain(or tissue) image.

The page contains 3-views of the tissue images (sagittalis, horizontal, coronal), and an additional 3D view of brain shell (mesh, may use Three.js).

The 3-views images are multi-resolution, can be zoomed in or out (Using OpenSeadragon) with mouse. Possibly multi-channeled and with brain region mask.

The same page contains a left pannel for control and information. There several tabs: 

  * Basic info and meta data about the sample and image;
  * For tuning the brightness and contrast of the image;
  * Enable/disable showing the brain region mask (overlayed(mixed) with the brain image);
  * Brain region list, that can be clicked (checked) to highlight the brain area.

URLs are copy-paste-friendly, i.e. user with the same URL should see the same page and same image position.


## backend

Python FastAPI server that privides basic info and images to the frontend. Specifically:

* The images of each demo specimen are stored in a hdf5 file, 3D image array with resolution pyramid. The backend serves the images that are suitable for frontend.

* Serves brain (or tissue) region list (names, ids) for each specimen.

* Serves brain (or tissue) region mask, also in hd5 file. the pixel values of the mask are the region ids. Generally has different resolution to corresponding images.


# Implementation plan

## Complete VISoR Platform Implementation Plan

### Final Architecture Overview

```mermaid
graph TB
    subgraph "Frontend (Vue.js + TypeScript)"
        A[Home Page] --> B[Atlas Viewer]
        B --> C[ViewerGrid - 4 Panels]
        C --> D[Sagittal View - YZ plane]
        C --> E[Coronal View - XZ plane] 
        C --> F[Horizontal View - XY plane]
        C --> G[3D Brain Shell]
        H[Control Panel] --> I[Metadata Tab]
        H --> J[Channel Controls]
        H --> K[Atlas Overlay]
        H --> L[Region Browser]
        M[Region Picker] --> N[Coordinate Transform]
        O[Pinia Store] --> B
        P[Vue Router] --> Q[URL State Management]
    end
    
    subgraph "Backend (FastAPI + Python)"
        R[FastAPI Server] --> S[Imaris Handler]
        R --> T[Tile Service]
        R --> U[Region Service]
        R --> V[Metadata Service]
        S --> W[HDF5 Image Data]
        T --> X[Image Tiles JPEG]
        T --> Y[Atlas Tiles PNG]
        U --> Z[Region Hierarchy JSON]
        AA[3D Model Service] --> BB[OBJ File Handler]
        CC[Coordinate Transform] --> DD[View Mapping]
    end
    
    subgraph "Data Layer"
        EE[Image: z00000_c1_1.ims]
        FF[Atlas: z00000_c1_mask.ims]
        GG[Model: 1.obj]
        HH[Regions: NIHMS696288-supplement-4.xlsx → JSON]
    end
    
    subgraph "Infrastructure"
        II[Docker Compose]
        JJ[Redis Cache]
        KK[Nginx Proxy]
    end
```

### Complete Project Structure

```
cerevi/
├── docker-compose.yml
├── .env.example
├── README.md
├── data/                                    # Symbolic links
│   ├── specimens/
│   │   └── macaque_brain_rm009/
│   │       ├── image.ims -> /share/data/VISoR_Reconstruction/...
│   │       └── atlas.ims -> /share/data/VISoR_Reconstruction/.../mask.ims
│   ├── models/
│   │   └── macaque_brain_rm009/
│   │       └── brain_shell.obj -> /mnt/xyy/SIAT_CAS/xu/tracing/.../1.obj
│   └── regions/
│       └── macaque_brain_regions.xlsx -> /mnt/xyy/SIAT_CAS/xu/.../NIHMS696288-supplement-4.xlsx
├── frontend/
│   ├── Dockerfile
│   ├── package.json
│   ├── vite.config.ts
│   ├── tsconfig.json
│   ├── tailwind.config.js
│   ├── src/
│   │   ├── main.ts
│   │   ├── App.vue
│   │   ├── router/
│   │   │   └── index.ts
│   │   ├── stores/
│   │   │   ├── specimen.ts               # Specimen data management
│   │   │   ├── viewer.ts                 # Viewer state (position, zoom, etc.)
│   │   │   ├── region.ts                 # Region hierarchy and selection
│   │   │   └── ui.ts                     # UI state (maximized view, etc.)
│   │   ├── views/
│   │   │   ├── HomePage.vue
│   │   │   └── AtlasViewer.vue
│   │   ├── components/
│   │   │   ├── layout/
│   │   │   │   ├── Header.vue
│   │   │   │   └── Footer.vue
│   │   │   ├── home/
│   │   │   │   ├── HeroSection.vue
│   │   │   │   ├── SpecimenGallery.vue
│   │   │   │   └── SpecimenCard.vue
│   │   │   ├── viewer/
│   │   │   │   ├── ViewerGrid.vue        # 4-panel layout manager
│   │   │   │   ├── ViewerPanel.vue       # Individual 2D/3D viewer
│   │   │   │   ├── ViewMaximizer.vue     # Maximized single view
│   │   │   │   ├── OpenSeadragonViewer.vue # 2D image viewer
│   │   │   │   └── ThreeJSViewer.vue     # 3D brain shell viewer
│   │   │   ├── controls/
│   │   │   │   ├── ControlPanel.vue      # Left panel container
│   │   │   │   ├── MetadataTab.vue       # Image info, dimensions
│   │   │   │   ├── ChannelTab.vue        # Channel selection, contrast
│   │   │   │   ├── AtlasTab.vue          # Atlas overlay controls
│   │   │   │   └── RegionTab.vue         # Hierarchical region browser
│   │   │   ├── region/
│   │   │   │   ├── RegionTree.vue        # Hierarchical tree display
│   │   │   │   ├── RegionSearch.vue      # Search regions
│   │   │   │   └── RegionPicker.vue      # Click-to-pick functionality
│   │   │   └── ui/
│   │   │       ├── LanguageToggle.vue
│   │   │       ├── LoadingSpinner.vue
│   │   │       └── ErrorBoundary.vue
│   │   ├── composables/
│   │   │   ├── useOpenSeadragon.ts       # OpenSeadragon integration
│   │   │   ├── useThreeJS.ts             # Three.js 3D visualization
│   │   │   ├── useViewerLayout.ts        # Grid/maximize state management
│   │   │   ├── useRegionPicker.ts        # Region picking logic
│   │   │   ├── useCoordinateTransform.ts # View coordinate mapping
│   │   │   ├── useImageControls.ts       # Brightness, contrast controls
│   │   │   └── useUrlState.ts            # URL state synchronization
│   │   ├── services/
│   │   │   ├── api.ts                    # Main API client
│   │   │   ├── tileService.ts            # Tile loading service
│   │   │   └── coordinateService.ts      # Coordinate transformations
│   │   ├── types/
│   │   │   ├── specimen.ts
│   │   │   ├── viewer.ts
│   │   │   ├── region.ts
│   │   │   └── api.ts
│   │   ├── utils/
│   │   │   ├── constants.ts
│   │   │   ├── helpers.ts
│   │   │   └── validation.ts
│   │   ├── locales/
│   │   │   ├── en.json
│   │   │   └── zh.json
│   │   └── assets/
│   │       ├── images/
│   │       └── styles/
│   └── public/
├── backend/
│   ├── Dockerfile
│   ├── requirements.txt
│   ├── app/
│   │   ├── main.py
│   │   ├── config.py                     # Configuration management
│   │   ├── models/
│   │   │   ├── specimen.py               # Specimen data models
│   │   │   ├── region.py                 # Region hierarchy models
│   │   │   ├── metadata.py               # Image metadata models
│   │   │   └── coordinate.py             # Coordinate system models
│   │   ├── services/
│   │   │   ├── imaris_handler.py         # .ims file reading
│   │   │   ├── tile_service.py           # Tile generation
│   │   │   ├── region_service.py         # Region data management
│   │   │   ├── coordinate_service.py     # Coordinate transformations
│   │   │   ├── obj_handler.py            # 3D model handling
│   │   │   ├── metadata_service.py       # Image metadata extraction
│   │   │   └── cache_service.py          # Redis caching
│   │   ├── api/
│   │   │   ├── specimens.py              # Specimen endpoints
│   │   │   ├── tiles.py                  # Tile serving endpoints
│   │   │   ├── regions.py                # Region endpoints
│   │   │   ├── metadata.py               # Metadata endpoints
│   │   │   └── models.py                 # 3D model endpoints
│   │   ├── utils/
│   │   │   ├── excel_parser.py           # Convert XLSX to JSON
│   │   │   ├── image_processing.py       # Image manipulation
│   │   │   ├── coordinate_math.py        # Coordinate calculations
│   │   │   └── validation.py             # Input validation
│   │   └── data/
│   │       └── processed/
│   │           └── regions.json          # Converted region hierarchy
│   └── tests/
├── nginx/
│   ├── Dockerfile
│   └── nginx.conf
└── scripts/
    ├── setup_data_links.sh               # Create symbolic links
    ├── convert_regions.py                # Convert XLSX to JSON
    └── init_dev_data.py                  # Initialize development data
```

### Coordinate System Implementation

#### Backend Coordinate Service:
```python
class CoordinateService:
    def __init__(self):
        # Image array is in (z, y, x) order
        # Right-handed coordinate system
        self.view_mappings = {
            'sagittal': {   # YZ plane (perpendicular to X-axis)
                'array_axes': (0, 1),  # z, y from (z,y,x)
                'display_axes': ('anterior-posterior', 'superior-inferior')
            },
            'coronal': {    # XZ plane (perpendicular to Y-axis)  
                'array_axes': (0, 2),  # z, x from (z,y,x)
                'display_axes': ('anterior-posterior', 'left-right')
            },
            'horizontal': { # XY plane (perpendicular to Z-axis)
                'array_axes': (1, 2),  # y, x from (z,y,x)
                'display_axes': ('superior-inferior', 'left-right')
            }
        }
    
    def get_slice_from_3d(self, data: np.ndarray, view: str, slice_idx: int) -> np.ndarray:
        if view == 'sagittal':
            return data[:, :, slice_idx]  # Fix X, vary Z,Y
        elif view == 'coronal':
            return data[:, slice_idx, :]  # Fix Y, vary Z,X
        elif view == 'horizontal':
            return data[slice_idx, :, :]  # Fix Z, vary Y,X
    
    def transform_3d_to_model(self, image_coords: tuple, resolution_um: float) -> tuple:
        # Transform from image coordinates to 3D model coordinates
        # Image resolution at level 0 is 10um
        # Model coordinates are in 10um units
        x, y, z = image_coords
        model_x = x * resolution_um / 10.0
        model_y = y * resolution_um / 10.0  
        model_z = z * resolution_um / 10.0
        return (model_x, model_z, -model_y)  # Note: Y becomes -Y in model
```

### Complete API Specification

#### Core Endpoints:
```python
# Specimen Management
GET /api/specimens                                    # List all specimens
GET /api/specimens/{id}                              # Get specimen details
GET /api/specimens/{id}/metadata                     # Complete metadata

# Tile Serving (configurable tile size, default 512x512)
GET /api/specimens/{id}/image/{view}/{level}/{z}/{x}/{y}?channel={ch}&tile_size={size}
GET /api/specimens/{id}/atlas/{view}/{level}/{z}/{x}/{y}?tile_size={size}

# Region System
GET /api/specimens/{id}/regions                      # Complete region hierarchy
GET /api/specimens/{id}/regions/{region_id}          # Specific region details
POST /api/specimens/{id}/pick-region                 # Pick region from coordinates
# Body: {"view": "sagittal", "x": 100, "y": 200, "z": 50, "level": 4}

# 3D Models
GET /api/specimens/{id}/model                        # Get 3D brain shell model
GET /api/specimens/{id}/model/metadata               # Model alignment info

# Metadata & Configuration
GET /api/specimens/{id}/image-info                   # Dimensions, levels, channels
GET /api/specimens/{id}/atlas-info                   # Atlas dimensions, levels
GET /api/specimens/{id}/config                       # Suggested tile size, etc.
```

### Region Hierarchy Data Structure

#### Converted JSON Format:
```json
{
  "regions": [
    {
      "id": 1,
      "name": "ventricles",
      "abbreviation": "LV",
      "level1": "ventricles",
      "level2": "ventricles", 
      "level3": "ventricles",
      "level4": "ventricles",
      "value": 1,
      "parent_id": null,
      "children": []
    },
    {
      "id": 2,
      "name": "medulla",
      "abbreviation": "Md",
      "level1": "hindbrain",
      "level2": "myelencephalon",
      "level3": "medulla",
      "level4": "medulla",
      "value": 2,
      "parent_id": null,
      "children": []
    }
  ],
  "hierarchy": {
    "hindbrain": {
      "myelencephalon": ["medulla"],
      "metencephalon": ["pons", "cerebellum"]
    },
    "midbrain": ["midbrain"],
    "forebrain": {
      "diencephalon": {
        "p2": ["thalamus"]
      }
    }
  }
}
```

### Frontend State Management (Pinia Stores)

#### Viewer Store:
```typescript
export const useViewerStore = defineStore('viewer', () => {
  const currentView = ref<'grid' | 'sagittal' | 'coronal' | 'horizontal' | '3d'>('grid')
  const viewerStates = ref({
    sagittal: { position: [0, 0, 0], zoom: 1, slice: 0 },
    coronal: { position: [0, 0, 0], zoom: 1, slice: 0 },
    horizontal: { position: [0, 0, 0], zoom: 1, slice: 0 }
  })
  const synchronizeViews = ref(true)
  const selectedRegion = ref<number | null>(null)
  const channelSettings = ref({
    activeChannels: [0],
    brightness: { 0: 50, 1: 50, 2: 50, 3: 50 },
    contrast: { 0: 50, 1: 50, 2: 50, 3: 50 }
  })
  
  const maximizeView = (view: string) => {
    currentView.value = view as any
  }
  
  const syncPosition = (sourceView: string, position: number[]) => {
    if (!synchronizeViews.value) return
    // Update corresponding positions in other views
  }
  
  return {
    currentView, viewerStates, synchronizeViews, selectedRegion,
    channelSettings, maximizeView, syncPosition
  }
})
```

### Performance & Caching Strategy

#### Backend Caching:
```python
class CacheService:
    def __init__(self):
        self.redis = redis.Redis(host='redis', port=6379, db=0)
        self.tile_cache_ttl = 3600  # 1 hour
        self.metadata_cache_ttl = 86400  # 24 hours
    
    def get_tile_cache_key(self, specimen_id: str, tile_type: str, 
                          view: str, level: int, z: int, x: int, y: int, **kwargs) -> str:
        extras = "_".join([f"{k}={v}" for k, v in sorted(kwargs.items())])
        return f"tile:{specimen_id}:{tile_type}:{view}:{level}:{z}:{x}:{y}:{extras}"
    
    async def get_cached_tile(self, cache_key: str) -> Optional[bytes]:
        return await self.redis.get(cache_key)
    
    async def cache_tile(self, cache_key: str, tile_data: bytes):
        await self.redis.setex(cache_key, self.tile_cache_ttl, tile_data)
```

#### Frontend Optimizations:
- **Progressive loading**: Load low-resolution first, then high-resolution
- **Viewport culling**: Only load visible tiles
- **Memory management**: Dispose of off-screen tiles
- **Debounced updates**: Prevent excessive API calls during navigation

### Docker Composition

#### docker-compose.yml:
```yaml
version: '3.8'
services:
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    environment:
      - VITE_API_URL=http://localhost:8000
    depends_on:
      - backend
  
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - REDIS_URL=redis://redis:6379
    volumes:
      - ./data:/app/data:ro
    depends_on:
      - redis
  
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    command: redis-server --maxmemory 2gb --maxmemory-policy allkeys-lru
  
  nginx:
    build: ./nginx
    ports:
      - "80:80"
    depends_on:
      - frontend
      - backend
```

### Implementation Phases

#### Phase 1: Data Setup & Infrastructure
1. Create all symbolic links to data files
2. Convert XLSX region hierarchy to JSON
3. Set up basic Docker composition
4. Test data access and file reading

#### Phase 2: Backend Core
1. Implement ImarisHandler for .ims files
2. Create TileService with multi-resolution support
3. Build coordinate transformation system
4. Add caching layer with Redis

#### Phase 3: API Implementation
1. Create all REST endpoints
2. Implement region picking logic
3. Add 3D model serving
4. Test with real data

#### Phase 4: Frontend Foundation
1. Set up Vue.js project with TypeScript
2. Create routing and basic layout
3. Implement Pinia stores
4. Build ViewerGrid component

#### Phase 5: 2D Visualization
1. Integrate OpenSeadragon
2. Implement multi-view synchronization
3. Add region picking functionality
4. Create control panels

#### Phase 6: 3D Visualization
1. Three.js integration for brain shell
2. Coordinate alignment with 2D views
3. Interactive controls

#### Phase 7: Advanced Features
1. Multi-channel support
2. Region hierarchy browser
3. Atlas overlay system
4. URL state management

#### Phase 8: Polish & Optimization
1. Internationalization (EN/CN)
2. Performance optimization
3. Error handling and loading states
4. Documentation and testing

## Ready for Implementation

This comprehensive plan covers all aspects of the VISoR platform with real data integration. The architecture is designed for:

- **Scalability**: Modular structure, caching, efficient data handling
- **Performance**: Progressive loading, viewport culling, optimized tile serving
- **Usability**: Intuitive 4-panel layout, synchronized navigation, region picking
- **Maintainability**: Clear separation of concerns, TypeScript types, comprehensive testing


# Next

Carefully check what have been done, and what have been done wrong. If it done wrong, fix it.

If there are still something left, continue follow plan.

If there are some redundent code, optimize it, and keep readability.

Also, use programmatic value instead of hard-coded value for image size related values in front end.

